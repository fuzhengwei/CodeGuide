---
layout: post
category: itstack-demo-jvm
title: ç”¨Javaå®ç°JVMç¬¬ä¸ƒç« ã€Šæ–¹æ³•è°ƒç”¨å’Œè¿”å›ã€‹
tagline: by ä»˜æ”¿å§”
tag: [jvm,itstack-demo-jvm]
---

# ç”¨Javaå®ç°JVMç¬¬ä¸ƒç« ã€Šæ–¹æ³•è°ƒç”¨å’Œè¿”å›ã€‹

ä½œè€…ï¼šå°å‚…å“¥
<br/>åšå®¢ï¼š[https://bugstack.cn](https://bugstack.cn)

> æ²‰æ·€ã€åˆ†äº«ã€æˆé•¿ï¼Œè®©è‡ªå·±å’Œä»–äººéƒ½èƒ½æœ‰æ‰€æ”¶è·ï¼ğŸ˜„

## æ¡ˆä¾‹ä»‹ç»
æœ¬ç« èŠ‚ä¸»è¦ç”¨javaå®ç°ï¼›æ–¹æ³•è°ƒç”¨æŒ‡ä»¤ã€è¿”å›æŒ‡ä»¤ã€è§£ææ–¹æ³•ç¬¦å·å¼•ç”¨ã€å‚æ•°ä¼ é€’ç­‰ã€‚å®ç°æ–°çš„æŒ‡ä»¤åæˆ‘ä»¬çš„è™šæ‹Ÿæœºå°±å¯ä»¥æ‰§è¡Œç¨å¾®å¤æ‚çš„è¿ç®—å¹¶è¾“å‡ºç»“æœã€‚

>ä»è°ƒç”¨çš„è§’åº¦æ¥çœ‹ï¼Œæ–¹æ³•å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šé™æ€æ–¹æ³•ï¼ˆæˆ–è€…ç±»æ–¹æ³•ï¼‰å’Œå®ä¾‹æ–¹æ³•ã€‚é™æ€æ–¹æ³•é€šè¿‡ç±»ç±»è°ƒç”¨ï¼Œå®ä¾‹æ–¹æ³•åˆ™é€šè¿‡å¯¹è±¡å¼•ç”¨æ¥è°ƒç”¨ã€‚é™æ€æ–¹æ³•æ˜¯é™æ€ç»‘å®šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€ç»ˆè°ƒç”¨çš„æ˜¯å“ªç»™æ–¹æ³•åœ¨ç¼–è¯‘æœŸå°±å·²ç»ç¡®å®šã€‚å®ä¾‹æ–¹æ³•åˆ™æ”¯æŒåŠ¨æ€ç»‘å®šï¼Œæœ€ç»ˆè¦è°ƒç”¨å“ªç»™æ–¹æ³•å¯èƒ½è¦æ¨è¿Ÿåˆ°è¿è¡ŒæœŸæ‰èƒ½çŸ¥é“ã€‚

>ä»å®ç°çš„è§’åº¦æ¥çœ‹ï¼Œæ–¹æ³•å¯ä»¥åˆ†ä¸ºä¸‰ç±»ï¼šæ²¡æœ‰å®ç°ï¼ˆä¹Ÿå°±æ˜¯æŠ½è±¡æ–¹æ³•ï¼‰ã€ç”¨Javaè¯­è¨€ï¼ˆæˆ–è€…JVMä¸Šå…¶ä»–çš„è¯­è¨€ï¼Œå¦‚Groovyå’ŒScalaç­‰ï¼‰å®ç°å’Œç”¨æœ¬åœ°è¯­è¨€ï¼ˆå¦‚Cæˆ–è€…C++ï¼‰å®ç°ã€‚é™æ€æ–¹æ³•å’ŒæŠ½è±¡æ–¹æ³•æ˜¯äº’æ–¥çš„ã€‚åœ¨Java 8ä¹‹å‰ï¼Œæ¥å£åªèƒ½åŒ…æ‹¬æŠ½è±¡æ–¹æ³•ã€‚ä¸ºäº†å®ç°Lambdaè¡¨è¾¾å¼ï¼ŒJava 8æ”¾å®½äº†è¿™ä¸€é™åˆ¶ï¼Œåœ¨æ¥å£ä¸­ä¹Ÿå¯ä»¥å®šä¹‰é™æ€æ–¹æ³•å’Œé»˜è®¤æ–¹æ³•ã€‚

>åœ¨Java 7ä¹‹å‰ï¼ŒJavaè™šæ‹Ÿæœºè§„èŒƒä¸€å…±æä¾›äº†4æ¡æ–¹æ³•è°ƒç”¨æŒ‡ä»¤ã€‚å…¶ä¸­invokestaticæŒ‡ä»¤ç”¨æ¥è°ƒç”¨é™æ€æ–¹æ³•ã€‚invokespecialæŒ‡ä»¤ç”¨æ¥è°ƒç”¨æ— é¡»åŠ¨æ€ç»‘å®šçš„å®ä¾‹æ–¹æ³•ï¼ŒåŒ…æ‹¬æ„é€ å‡½æ•°ã€ç§æœ‰æ–¹æ³•å’Œé€šè¿‡superå…³é”®å­—è°ƒç”¨çš„è¶…ç±»æ–¹æ³•ã€‚å‰©ä¸‹çš„æƒ…å†µåˆ™å±äºåŠ¨æ€ç»‘å®šã€‚å¦‚æœæ˜¯é’ˆå¯¹æ¥å£ç±»å‹çš„å¼•ç”¨è°ƒç”¨æ–¹æ³•ï¼Œå°±ä½¿ç”¨invokeinterfaceæŒ‡ä»¤ï¼Œå¦åˆ™ä½¿ç”¨invokevirtualæŒ‡ä»¤ã€‚

## ç¯å¢ƒå‡†å¤‡
1. jdk 1.8.0
2. IntelliJ IDEA Community Edition 2018.3.1 x64

## é…ç½®ä¿¡æ¯
1. è°ƒè¯•é…ç½®
    1. é…ç½®ä½ç½®ï¼šRun/Debug Configurations -> program arguments
    2. é…ç½®å†…å®¹ï¼ˆé€‰é… verbose trueï¼‰ï¼š-Xjre "C:\Program Files\Java\jdk1.8.0_161\jre" E:\itstack\git\istack-demo\itstack-demo-jvm\itstack-demo-jvm-07\target\test-classes\org\itstack\demo\test\HelloWorld verbose true

## ä»£ç ç¤ºä¾‹
```java
itstack-demo-jvm-07
â”œâ”€â”€ pom.xml
â””â”€â”€ src
    â””â”€â”€ main
    â”‚    â””â”€â”€ java
    â”‚        â””â”€â”€ org.itstack.demo.jvm
    â”‚             â”œâ”€â”€ classfile
    â”‚             â”‚   â”œâ”€â”€ attributes   {BootstrapMethods/Code/ConstantValue...}
    â”‚             â”‚   â”œâ”€â”€ constantpool {CONSTANT_TAG_CLASS/CONSTANT_TAG_FIELDREF/CONSTANT_TAG_METHODREF...}
    â”‚             â”‚   â”œâ”€â”€ ClassFile.java
    â”‚             â”‚   â”œâ”€â”€ ClassReader.java
    â”‚             â”‚   â””â”€â”€ MemberInfo.java   
    â”‚             â”œâ”€â”€ classpath
    â”‚             â”‚   â”œâ”€â”€ impl
    â”‚             â”‚   â”‚   â”œâ”€â”€ CompositeEntry.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ DirEntry.java 
    â”‚             â”‚   â”‚   â”œâ”€â”€ WildcardEntry.java 
    â”‚             â”‚   â”‚   â””â”€â”€ ZipEntry.java    
    â”‚             â”‚   â”œâ”€â”€ Classpath.java
    â”‚             â”‚   â””â”€â”€ Entry.java   
    â”‚             â”œâ”€â”€ classpath
    â”‚             â”‚   â”œâ”€â”€ base
    â”‚             â”‚   â”‚   â”œâ”€â”€ BytecodeReader.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ ClassInitLogic.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ Instruction.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionBranch.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionIndex8.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionIndex16.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionNoOperands.java	
    â”‚             â”‚   â”‚   â””â”€â”€ MethodInvokeLogic.java
    â”‚             â”‚   â”œâ”€â”€ comparisons
    â”‚             â”‚   â”œâ”€â”€ constants
    â”‚             â”‚   â”œâ”€â”€ control
    â”‚             â”‚   â”œâ”€â”€ conversions
    â”‚             â”‚   â”œâ”€â”€ extended
    â”‚             â”‚   â”œâ”€â”€ loads
    â”‚             â”‚   â”œâ”€â”€ math
    â”‚             â”‚   â”œâ”€â”€ references
    â”‚             â”‚   â”‚   â”œâ”€â”€ CHECK_CAST.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ GET_FIELD.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ GET_STATIC.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INSTANCE_OF.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_INTERFACE.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_SPECIAL.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_STATIC.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_VIRTUAL.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ NEW.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ PUT_FIELD.java
    â”‚             â”‚   â”‚   â””â”€â”€ PUT_STATIC.java
    â”‚             â”‚   â”œâ”€â”€ stack
    â”‚             â”‚   â”œâ”€â”€ store
    â”‚             â”‚   â””â”€â”€ Factory   
    â”‚             â”œâ”€â”€ rtda
    â”‚             â”‚   â”œâ”€â”€ heap
    â”‚             â”‚   â”‚   â”œâ”€â”€ constantpool
    â”‚             â”‚   â”‚   â”œâ”€â”€ methodarea
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Class.java    
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ ClassMember.java  
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Field.java    
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Method.java 
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ MethodDescriptor.java 
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ MethodDescriptorParser.java 
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ MethodLookup.java 	
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Object.java   
    â”‚             â”‚   â”‚   â”‚   â””â”€â”€ Slots.java        
    â”‚             â”‚   â”‚   â””â”€â”€ ClassLoader.java  
    â”‚             â”‚   â”œâ”€â”€ Frame.java
    â”‚             â”‚   â”œâ”€â”€ JvmStack.java
    â”‚             â”‚   â”œâ”€â”€ LocalVars.java
    â”‚             â”‚   â”œâ”€â”€ OperandStack.java
    â”‚             â”‚   â”œâ”€â”€ Slot.java 
    â”‚             â”‚   â””â”€â”€ Thread.java
    â”‚             â”œâ”€â”€ Cmd.java
    â”‚             â”œâ”€â”€ Interpret.java    
    â”‚             â””â”€â”€ Main.java
    â””â”€â”€ test
         â””â”€â”€ java
             â””â”€â”€ org.itstack.demo.test
                 â””â”€â”€ HelloWorld.java
```

ä»£ç ç¯‡å¹…è¾ƒé•¿ï¼Œåªåˆ—é‡ç‚¹ä»£ç å—

>MethodInvokeLogic.java

```java
package org.itstack.demo.jvm.instructions.base;

import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.Slot;
import org.itstack.demo.jvm.rtda.Thread;
import org.itstack.demo.jvm.rtda.heap.methodarea.Method;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/28
 */
public class MethodInvokeLogic {

    public static void invokeMethod(Frame invokerFrame, Method method) {
        Thread thread = invokerFrame.thread();
        Frame newFrame = thread.newFrame(method);
        thread.pushFrame(newFrame);

        int argSlotCount = method.argSlotCount();
        if (argSlotCount > 0) {
            for (int i = argSlotCount - 1; i >= 0; i--) {
                Slot slot = invokerFrame.operandStack().popSlot();
                newFrame.localVars().setSlot(i, slot);
            }
        }

        //hack
        if (method.isNative()) {
            if ("registerNatives".equals(method.name())) {
                thread.popFrame();
            } else {
                throw new RuntimeException("native method " + method.name());
            }
        }
    }

}
```

>INVOKE_INTERFACE.java

```java
package org.itstack.demo.jvm.instructions.references;

import org.itstack.demo.jvm.instructions.base.BytecodeReader;
import org.itstack.demo.jvm.instructions.base.Instruction;
import org.itstack.demo.jvm.instructions.base.MethodInvokeLogic;
import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.heap.constantpool.InterfaceMethodRef;
import org.itstack.demo.jvm.rtda.heap.constantpool.RunTimeConstantPool;
import org.itstack.demo.jvm.rtda.heap.methodarea.Method;
import org.itstack.demo.jvm.rtda.heap.methodarea.MethodLookup;
import org.itstack.demo.jvm.rtda.heap.methodarea.Object;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/28
 */
public class INVOKE_INTERFACE implements Instruction {

    private int idx;

    @Override
    public void fetchOperands(BytecodeReader reader) {
        this.idx = reader.readShort();
        reader.readByte();
        reader.readByte();
    }

    @Override
    public void execute(Frame frame) {
        RunTimeConstantPool runTimeConstantPool = frame.method().clazz().constantPool();
        InterfaceMethodRef methodRef = (InterfaceMethodRef) runTimeConstantPool.getConstants(this.idx);
        Method resolvedMethod = methodRef.resolvedInterfaceMethod();
        if (resolvedMethod.isStatic() || resolvedMethod.isPrivate()) {
            throw new IncompatibleClassChangeError();
        }
        Object ref = frame.operandStack().getRefFromTop(resolvedMethod.argSlotCount() - 1);
        if (null == ref) {
            throw new NullPointerException();
        }
        if (!ref.clazz().isImplements(methodRef.resolvedClass())) {
            throw new IncompatibleClassChangeError();
        }
        Method methodToBeInvoked = MethodLookup.lookupMethodInClass(ref.clazz(), methodRef.name(), methodRef.descriptor());
        if (null == methodToBeInvoked || methodToBeInvoked.isAbstract()) {
            throw new AbstractMethodError();
        }
        if (!methodToBeInvoked.isPublic()) {
            throw new IllegalAccessError();
        }

        MethodInvokeLogic.invokeMethod(frame, methodToBeInvoked);

    }

}
```

>INVOKE_SPECIAL.java

```java
package org.itstack.demo.jvm.instructions.references;

import org.itstack.demo.jvm.instructions.base.InstructionIndex16;
import org.itstack.demo.jvm.instructions.base.MethodInvokeLogic;
import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.heap.constantpool.MethodRef;
import org.itstack.demo.jvm.rtda.heap.constantpool.RunTimeConstantPool;
import org.itstack.demo.jvm.rtda.heap.methodarea.Class;
import org.itstack.demo.jvm.rtda.heap.methodarea.Method;
import org.itstack.demo.jvm.rtda.heap.methodarea.MethodLookup;
import org.itstack.demo.jvm.rtda.heap.methodarea.Object;

public class INVOKE_SPECIAL extends InstructionIndex16 {

    @Override
    public void execute(Frame frame) {
        Class currentClass = frame.method().clazz();
        RunTimeConstantPool runTimeConstantPool = currentClass.constantPool();
        MethodRef methodRef = (MethodRef) runTimeConstantPool.getConstants(this.idx);
        Class resolvedClass = methodRef.resolvedClass();
        Method resolvedMethod = methodRef.ResolvedMethod();
        if ("<init>".equals(resolvedMethod.name()) && resolvedMethod.clazz() != resolvedClass) {
            throw new NoSuchMethodError();
        }
        if (resolvedMethod.isStatic()) {
            throw new IncompatibleClassChangeError();
        }

        Object ref = frame.operandStack().getRefFromTop(resolvedMethod.argSlotCount() - 1);
        if (null == ref) {
            throw new NullPointerException();
        }

        if (resolvedMethod.isProtected() &&
                resolvedMethod.clazz().isSubClassOf(currentClass) &&
                !resolvedMethod.clazz().getPackageName().equals(currentClass.getPackageName()) &&
                ref.clazz() != currentClass &&
                !ref.clazz().isSubClassOf(currentClass)) {
            throw new IllegalAccessError();
        }

        Method methodToBeInvoked = resolvedMethod;
        if (currentClass.isSuper() &&
                resolvedClass.isSubClassOf(currentClass) &&
                !resolvedMethod.name().equals("<init>")) {
            MethodLookup.lookupMethodInClass(currentClass.superClass, methodRef.name(), methodRef.descriptor());
        }

        if (methodToBeInvoked.isAbstract()) {
            throw new AbstractMethodError();
        }

        MethodInvokeLogic.invokeMethod(frame, methodToBeInvoked);

    }

}
```

>INVOKE_STATIC.java

```java
package org.itstack.demo.jvm.instructions.references;

import org.itstack.demo.jvm.instructions.base.ClassInitLogic;
import org.itstack.demo.jvm.instructions.base.InstructionIndex16;
import org.itstack.demo.jvm.instructions.base.MethodInvokeLogic;
import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.heap.constantpool.MethodRef;
import org.itstack.demo.jvm.rtda.heap.constantpool.RunTimeConstantPool;
import org.itstack.demo.jvm.rtda.heap.methodarea.Class;
import org.itstack.demo.jvm.rtda.heap.methodarea.Method;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/28
 */
public class INVOKE_STATIC extends InstructionIndex16 {

    @Override
    public void execute(Frame frame) {
        RunTimeConstantPool runTimeConstantPool = frame.method().clazz().constantPool();
        MethodRef methodRef = (MethodRef) runTimeConstantPool.getConstants(this.idx);
        Method resolvedMethod = methodRef.ResolvedMethod();

        if (!resolvedMethod.isStatic()) {
            throw new IncompatibleClassChangeError();
        }

        Class clazz = resolvedMethod.clazz();
        if (!clazz.initStarted()) {
            frame.revertNextPC();
            ClassInitLogic.initClass(frame.thread(), clazz);
            return;
        }

        MethodInvokeLogic.invokeMethod(frame, resolvedMethod);
    }
}
```

>INVOKE_VIRTUAL.java

```java
package org.itstack.demo.jvm.instructions.references;

import org.itstack.demo.jvm.instructions.base.InstructionIndex16;
import org.itstack.demo.jvm.instructions.base.MethodInvokeLogic;
import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.OperandStack;
import org.itstack.demo.jvm.rtda.heap.constantpool.MethodRef;
import org.itstack.demo.jvm.rtda.heap.constantpool.RunTimeConstantPool;
import org.itstack.demo.jvm.rtda.heap.methodarea.Class;
import org.itstack.demo.jvm.rtda.heap.methodarea.Method;
import org.itstack.demo.jvm.rtda.heap.methodarea.MethodLookup;
import org.itstack.demo.jvm.rtda.heap.methodarea.Object;

public class INVOKE_VIRTUAL extends InstructionIndex16 {

    @Override
    public void execute(Frame frame) {

        Class currentClass = frame.method().clazz();
        RunTimeConstantPool runTimeConstantPool = currentClass.constantPool();
        MethodRef methodRef = (MethodRef) runTimeConstantPool.getConstants(this.idx);
        Method resolvedMethod = methodRef.ResolvedMethod();
        if (resolvedMethod.isStatic()) {
            throw new IncompatibleClassChangeError();
        }

        Object ref = frame.operandStack().getRefFromTop(resolvedMethod.argSlotCount() - 1);
        if (null == ref) {
            if ("println".equals(methodRef.name())) {
                _println(frame.operandStack(), methodRef.descriptor());
                return;
            }
            throw new NullPointerException();
        }

        if (resolvedMethod.isProtected() &&
                resolvedMethod.clazz().isSubClassOf(currentClass) &&
                !resolvedMethod.clazz().getPackageName().equals(currentClass.getPackageName()) &&
                ref.clazz() != currentClass &&
                !ref.clazz().isSubClassOf(currentClass)) {
            throw new IllegalAccessError();
        }

        Method methodToBeInvoked = MethodLookup.lookupMethodInClass(ref.clazz(), methodRef.name(), methodRef.descriptor());
        if (null == methodToBeInvoked || methodToBeInvoked.isAbstract()) {
            throw new AbstractMethodError();
        }

        MethodInvokeLogic.invokeMethod(frame, methodToBeInvoked);
    }

    //hack
    private void _println(OperandStack stack, String descriptor) {
        switch (descriptor) {
            case "(Z)V":
                System.out.println(stack.popInt() != 0);
                break;
            case "(C)V":
                System.out.println(stack.popInt());
                break;
            case "(I)V":
            case "(B)V":
            case "(S)V":
                System.out.println(stack.popInt());
                break;
            case "(F)V":
                System.out.println(stack.popFloat());
                break;
            case "(J)V":
                System.out.println(stack.popLong());
                break;
            case "(D)V":
                System.out.println(stack.popDouble());
                break;
            default:
                System.out.println(descriptor);
                break;
        }
        stack.popRef();
    }
}
```

>MethodDescriptor.java 

```java
package org.itstack.demo.jvm.rtda.heap.methodarea;

import java.util.ArrayList;
import java.util.List;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/28
 */
public class MethodDescriptor {

    public List<String> parameterTypes = new ArrayList<>();
    public String returnType;

    public void addParameterType(String type){
        this.parameterTypes.add(type);
    }

}
```

>MethodDescriptorParser.java

```java
package org.itstack.demo.jvm.rtda.heap.methodarea;

import javax.management.ObjectName;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/28
 */
public class MethodDescriptorParser {

    private String raw;
    private int offset;
    private MethodDescriptor parsed;

    public static MethodDescriptor parseMethodDescriptorParser(String descriptor) {
        MethodDescriptorParser parser = new MethodDescriptorParser();
        return parser.parse(descriptor);
    }

    public MethodDescriptor parse(String descriptor) {
        this.raw = descriptor;
        this.parsed = new MethodDescriptor();
        this.startParams();
        this.parseParamTypes();
        this.endParams();
        this.parseReturnType();
        this.finish();
        return this.parsed;
    }

    private void startParams() {
        if (this.readUint8() != '(') {
            causePanic();
        }
    }

    private void endParams() {
        if (this.readUint8() != ')') {
            causePanic();
        }
    }

    public void finish(){
        if (this.offset != this.raw.length()){
            this.causePanic();
        }
    }

    public void causePanic() {
        throw new RuntimeException("BAD descriptorï¼š" + this.raw);
    }

    public byte readUint8() {
        byte[] bytes = this.raw.getBytes();
        byte b = bytes[this.offset];
        this.offset++;
        return b;
    }

    public void unreadUint8() {
        this.offset--;
    }

    public void parseParamTypes() {
        while (true) {
            String type = this.parseFieldType();
            if ("".equals(type)) break;
            this.parsed.addParameterType(type);
        }
    }

    public void parseReturnType() {
        if (this.readUint8() == 'V'){
            this.parsed.returnType = "V";
            return;
        }

        this.unreadUint8();
        String type = this.parseFieldType();
        if (!"".equals(type)){
            this.parsed.returnType = type;
            return;
        }

        this.causePanic();
    }

    public String parseFieldType() {
        switch (this.readUint8()) {
            case 'B':
                return "B";
            case 'C':
                return "C";
            case 'D':
                return "D";
            case 'F':
                return "F";
            case 'I':
                return "I";
            case 'J':
                return "J";
            case 'S':
                return "S";
            case 'Z':
                return "Z";
            case 'L':
                return this.parseObjectType();
            case '[':
                return this.parseArrayType();
            default:
                this.unreadUint8();
                return "";
        }
    }

    private String parseObjectType() {
        String unread = this.raw.substring(this.offset);
        int semicolonIndx = unread.indexOf(";");
        if (semicolonIndx == -1) {
            this.causePanic();
            return "";
        }
        int objStart = this.offset - 1;
        int ojbEnd = this.offset + semicolonIndx + 1;
        this.offset = ojbEnd;
        //descriptor
        return this.raw.substring(objStart, ojbEnd);
    }

    private String parseArrayType() {
        int arrStart = this.offset - 1;
        this.parseFieldType();
        int arrEnd = this.offset;
        //descriptor
        return this.raw.substring(arrStart, arrEnd);
    }


}
```

>MethodLookup.java

```java
package org.itstack.demo.jvm.rtda.heap.methodarea;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/28
 */
public class MethodLookup {

    static public Method lookupMethodInClass(Class clazz, String name, String descriptor) {
        for (Class c = clazz; c != null; c = c.superClass) {
            for (Method method : c.methods) {
                if (method.name.equals(name) && method.descriptor.equals(descriptor)) {
                    return method;
                }
            }
        }
        return null;
    }

    static public Method lookupMethodInInterfaces(Class[] ifaces, String name, String descriptor) {
        for (Class inface : ifaces) {
            for (Method method : inface.methods) {
                if (method.name.equals(name) && method.descriptor.equals(descriptor)) {
                    return method;
                }
            }
        }
        return null;
    }

}
```

>Interpret.java

```java
//æŒ‡ä»¤é›†è§£é‡Šå™¨
class Interpret {

    Interpret(Method method, boolean logInst) {
        Thread thread = new Thread();
        Frame frame = thread.newFrame(method);
        thread.pushFrame(frame);

        loop(thread, logInst);
    }

    private void loop(Thread thread, boolean logInst) {
        BytecodeReader reader = new BytecodeReader();
        while (true) {
            Frame frame = thread.currentFrame();
            int pc = frame.nextPC();
            thread.setPC(pc);

            reader.reset(frame.method().code, pc);
            byte opcode = reader.readByte();
            Instruction inst = Factory.newInstruction(opcode);
            if (null == inst) {
                System.out.println("Unsupported opcode " + byteToHexString(new byte[]{opcode}));
                break;
            }
            inst.fetchOperands(reader);
            frame.setNextPC(reader.pc());

            if (logInst) {
                logInstruction(frame, inst, opcode);
            }

            //exec
            inst.execute(frame);

            if (thread.isStackEmpty()) {
                break;
            }
        }
    }

    private static void logInstruction(Frame frame, Instruction inst, byte opcode) {
        Method method = frame.method();
        String className = method.clazz().name();
        String methodName = method.name();
        String outStr = (className + "." + methodName + "() \t") +
                "å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š" + byteToHexString(new byte[]{opcode}) + " -> " + inst.getClass().getSimpleName() + " => å±€éƒ¨å˜é‡è¡¨ï¼š" + JSON.toJSONString(frame.operandStack().getSlots()) + " æ“ä½œæ•°æ ˆï¼š" + JSON.toJSONString(frame.operandStack().getSlots());
        System.out.println(outStr);
    }

    private static String byteToHexString(byte[] codes) {
        StringBuilder sb = new StringBuilder();
        sb.append("0x");
        for (byte b : codes) {
            int value = b & 0xFF;
            String strHex = Integer.toHexString(value);
            if (strHex.length() < 2) {
                strHex = "0" + strHex;
            }
            sb.append(strHex);
        }
        return sb.toString();
    }

}
```

>HelloWorld.java

```java
public class HelloWorld {

    public static void main(String[] args) {
        long x = fibonacci(10);
        System.out.println(x);
    }

    //æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆFibonacci sequenceï¼‰
    private static long fibonacci(long n) {
        if (n <= 1) {
            return n;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

}
```

>æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆFibonacci sequenceï¼‰ï¼Œåˆç§°é»„é‡‘åˆ†å‰²æ•°åˆ—ã€å› æ•°å­¦å®¶åˆ—æ˜‚çº³å¤šÂ·æ–æ³¢é‚£å¥‘ï¼ˆLeonardoda Fibonacciï¼‰ä»¥å…”å­ç¹æ®–ä¸ºä¾‹å­è€Œå¼•å…¥ï¼Œæ•…åˆç§°ä¸ºâ€œå…”å­æ•°åˆ—â€ï¼ŒæŒ‡çš„æ˜¯è¿™æ ·ä¸€ä¸ªæ•°åˆ—ï¼š1ã€1ã€2ã€3ã€5ã€8ã€13ã€21ã€34ã€â€¦â€¦åœ¨æ•°å­¦ä¸Šï¼Œæ–æ³¢çº³å¥‘æ•°åˆ—ä»¥å¦‚ä¸‹è¢«ä»¥é€’æ¨çš„æ–¹æ³•å®šä¹‰ï¼šF(1)=1ï¼ŒF(2)=1, F(n)=F(n-1)+F(n-2)ï¼ˆn>=3ï¼ŒnâˆˆN*ï¼‰åœ¨ç°ä»£ç‰©ç†ã€å‡†æ™¶ä½“ç»“æ„ã€åŒ–å­¦ç­‰é¢†åŸŸï¼Œæ–æ³¢çº³å¥‘æ•°åˆ—éƒ½æœ‰ç›´æ¥çš„åº”ç”¨ï¼Œä¸ºæ­¤ï¼Œç¾å›½æ•°å­¦ä¼šä»1963å¹´èµ·å‡ºç‰ˆäº†ä»¥ã€Šæ–æ³¢çº³å¥‘æ•°åˆ—å­£åˆŠã€‹ä¸ºåçš„ä¸€ä»½æ•°å­¦æ‚å¿—ï¼Œç”¨äºä¸“é—¨åˆŠè½½è¿™æ–¹é¢çš„ç ”ç©¶æˆæœã€‚


## æµ‹è¯•ç»“æœ {jvmæ‰§è¡Œå¤æ‚è®¡ç®—ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œè¾“å‡ºç»“æœ55}

HelloWorld.fibonacci æŒ‡ä»¤ï¼š
```java
lload_0
lconst_1
lcmp
ifgt 7
lload_0
lreturn
lload_0
lconst_1
lsub
invokestatic org/itstack/demo/test/HelloWorld/fibonacci(J)J
lload_0
ldc2_w 2
lsub
invokestatic org/itstack/demo/test/HelloWorld/fibonacci(J)J
ladd
lreturn
```

æ‰§è¡Œè¿‡ç¨‹ï¼š
```java
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x14 -> LDC2_W => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb8 -> INVOKE_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":10},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":10},{"num":0},{"num":0}]
java/lang/Object.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb8 -> INVOKE_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼šnull æ“ä½œæ•°æ ˆï¼šnull
java/lang/Object.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb1 -> RETURN => å±€éƒ¨å˜é‡è¡¨ï¼šnull æ“ä½œæ•°æ ˆï¼šnull
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb8 -> INVOKE_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":10},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":10},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1e -> LLOAD_0 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x0a -> LCONST_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":10},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":10},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x94 -> LCMP => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":10},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":10},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x9d -> IFGT => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1e -> LLOAD_0 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x0a -> LCONST_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":10},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":10},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x65 -> LSUB => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":10},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":10},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb8 -> INVOKE_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1e -> LLOAD_0 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x0a -> LCONST_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":9},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":9},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x94 -> LCMP => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x9d -> IFGT => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1e -> LLOAD_0 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x0a -> LCONST_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x65 -> LSUB => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":9},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb8 -> INVOKE_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1e -> LLOAD_0 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x0a -> LCONST_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":8},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":8},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x94 -> LCMP => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x9d -> IFGT => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1e -> LLOAD_0 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":1},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x0a -> LCONST_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x65 -> LSUB => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":8},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb8 -> INVOKE_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":7},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":7},{"num":0},{"num":1},{"num":0},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1e -> LLOAD_0 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0},{"num":0},{"num":0},{"num":0},{"num":0},{"num":0}]

... ...

org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xad -> LRETURN => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":1},{"num":0},{"num":0},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":1},{"num":0},{"num":0},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x61 -> LADD => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":2},{"num":0},{"num":1},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":2},{"num":0},{"num":1},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xad -> LRETURN => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":3},{"num":0},{"num":1},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":3},{"num":0},{"num":1},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x61 -> LADD => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":5},{"num":0},{"num":3},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":5},{"num":0},{"num":3},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xad -> LRETURN => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":8},{"num":0},{"num":3},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":8},{"num":0},{"num":3},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x61 -> LADD => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":13},{"num":0},{"num":8},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":13},{"num":0},{"num":8},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xad -> LRETURN => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":21},{"num":0},{"num":8},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":21},{"num":0},{"num":8},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x61 -> LADD => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":34},{"num":0},{"num":21},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":34},{"num":0},{"num":21},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.fibonacci() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xad -> LRETURN => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":55},{"num":0},{"num":21},{"num":0},{"num":2},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":55},{"num":0},{"num":21},{"num":0},{"num":2},{"num":0}]
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x40 -> LSTORE_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":55},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":55},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb2 -> GET_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":55},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":55},{"num":0},{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb8 -> INVOKE_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x01 -> ACONST_NULL => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb3 -> PUT_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x01 -> ACONST_NULL => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb3 -> PUT_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x01 -> ACONST_NULL => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb3 -> PUT_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x01 -> ACONST_NULL => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb3 -> PUT_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x01 -> ACONST_NULL => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb3 -> PUT_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
java/lang/System.<clinit>() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb1 -> RETURN => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":0}]
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb2 -> GET_STATIC => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":55},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":55},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0x1f -> LLOAD_1 => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":55},{"num":0},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":55},{"num":0},{"num":0}]
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb6 -> INVOKE_VIRTUAL => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":55},{"num":55},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":55},{"num":55},{"num":0}]
55
org/itstack/demo/test/HelloWorld.main() 	å¯„å­˜å™¨(æŒ‡ä»¤)ï¼š0xb1 -> RETURN => å±€éƒ¨å˜é‡è¡¨ï¼š[{"num":55},{"num":55},{"num":0}] æ“ä½œæ•°æ ˆï¼š[{"num":55},{"num":55},{"num":0}]
```

å¾®ä¿¡æœç´¢ã€Œ**bugstackè™«æ´æ ˆ**ã€å…¬ä¼—å·ï¼Œå…³æ³¨åå›å¤ã€Œ**ç”¨Javaå®ç°jvmæºç **ã€è·å–æœ¬æ–‡æºç &æ›´å¤šåŸåˆ›ä¸“é¢˜æ¡ˆä¾‹ï¼
