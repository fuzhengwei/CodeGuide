---
layout: post
category: itstack-demo-jvm
title: ç”¨Javaå®ç°JVMç¬¬ä¹ç« ã€Šæœ¬åœ°æ–¹æ³•è°ƒç”¨ã€‹
tagline: by ä»˜æ”¿å§”
tag: [jvm,itstack-demo-jvm]
---

# ç”¨Javaå®ç°JVMç¬¬ä¹ç« ã€Šæœ¬åœ°æ–¹æ³•è°ƒç”¨ã€‹

ä½œè€…ï¼šå°å‚…å“¥
<br/>åšå®¢ï¼š[https://bugstack.cn](https://bugstack.cn)

> æ²‰æ·€ã€åˆ†äº«ã€æˆé•¿ï¼Œè®©è‡ªå·±å’Œä»–äººéƒ½èƒ½æœ‰æ‰€æ”¶è·ï¼ğŸ˜„

## æ¡ˆä¾‹ä»‹ç»
æœ¬ç« ä¸»è¦ä»‹ç»ç”¨javaå®ç°ä¸€äº›æœ¬åœ°æ–¹æ³•ç±»åº“ï¼Œå¹¶åˆå§‹åŒ–æœ¬åœ°æ–¹æ³•ï¼Œä¹‹åé€šè¿‡åå°„å‘½ä»¤æ¥è°ƒç”¨æœ¬åœ°æ–¹æ³•ã€‚

>Javaè™šæ‹Ÿæœºå’ŒJavaç±»åº“ä¸€èµ·æ„æˆäº†Javaè¿è¡Œæ—¶ç¯å¢ƒã€‚Javaç±»åº“ä¸»è¦ç”¨Javaè¯­è¨€ç¼–å†™ï¼Œä¸€äº›æ— æ³•ç”¨Javaè¯­è¨€å®ç°çš„æ–¹æ³•åˆ™ä½¿ç”¨æœ¬åœ°è¯­è¨€ç¼–å†™ï¼Œè¿™é¢æ–¹æ³•å«ä½œæœ¬åœ°æ–¹æ³•ã€‚
OpenJDKç±»åº“ä¸­çš„æœ¬åœ°æ–¹æ³•æ˜¯ç”¨JNIï¼ˆJava Native Interfaceï¼‰ç¼–å†™çš„ï¼Œä½†æ˜¯è¦è®©è™šæ‹Ÿæœºæ”¯æŒJNIè§„èŒƒè¿˜éœ€è¦å¤§é‡å·¥ä½œã€‚

## ç¯å¢ƒå‡†å¤‡
1. jdk 1.8.0
2. IntelliJ IDEA Community Edition 2018.3.1 x64

## é…ç½®ä¿¡æ¯
1. è°ƒè¯•é…ç½®
    1. é…ç½®ä½ç½®ï¼šRun/Debug Configurations -> program arguments
    2. é…ç½®å†…å®¹ï¼š-Xjre "C:\Program Files\Java\jdk1.8.0_161\jre" E:\itstack\git\istack-demo\itstack-demo-jvm\itstack-demo-jvm-09\target\test-classes\org\itstack\demo\test\HelloWorld

## ä»£ç ç¤ºä¾‹
```java
itstack-demo-jvm-09
â”œâ”€â”€ pom.xml
â””â”€â”€ src
    â””â”€â”€ main
    â”‚    â””â”€â”€ java
    â”‚        â””â”€â”€ org.itstack.demo.jvm
    â”‚             â”œâ”€â”€ _native
    â”‚             â”‚   â”œâ”€â”€ java
    â”‚             â”‚   â”‚   â”œâ”€â”€ _Class.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ _Double.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ _Float.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ _Object.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ _String.java
    â”‚             â”‚   â”‚   â””â”€â”€ _System.java	
    â”‚             â”‚   â””â”€â”€ sun	
    â”‚             â”œâ”€â”€ NativeMethod.java
    â”‚             â””â”€â”€ Registry.java	
    â”‚             â”œâ”€â”€ classfile
    â”‚             â”‚   â”œâ”€â”€ attributes   
    â”‚             â”‚   â”œâ”€â”€ constantpool 
    â”‚             â”‚   â”œâ”€â”€ ClassFile.java
    â”‚             â”‚   â”œâ”€â”€ ClassReader.java
    â”‚             â”‚   â””â”€â”€ MemberInfo.java   
    â”‚             â”œâ”€â”€ classpath
    â”‚             â”‚   â”œâ”€â”€ impl
    â”‚             â”‚   â”‚   â”œâ”€â”€ CompositeEntry.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ DirEntry.java 
    â”‚             â”‚   â”‚   â”œâ”€â”€ WildcardEntry.java 
    â”‚             â”‚   â”‚   â””â”€â”€ ZipEntry.java    
    â”‚             â”‚   â”œâ”€â”€ Classpath.java
    â”‚             â”‚   â””â”€â”€ Entry.java   
    â”‚             â”œâ”€â”€ classpath
    â”‚             â”‚   â”œâ”€â”€ base
    â”‚             â”‚   â”‚   â”œâ”€â”€ BytecodeReader.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ ClassInitLogic.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ Instruction.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionBranch.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionIndex8.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionIndex16.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ InstructionNoOperands.java	
    â”‚             â”‚   â”‚   â””â”€â”€ MethodInvokeLogic.java
    â”‚             â”‚   â”œâ”€â”€ comparisons
    â”‚             â”‚   â”œâ”€â”€ constants
    â”‚             â”‚   â”œâ”€â”€ control
    â”‚             â”‚   â”œâ”€â”€ conversions
    â”‚             â”‚   â”œâ”€â”€ extended
    â”‚             â”‚   â”œâ”€â”€ loads
    â”‚             â”‚   â”œâ”€â”€ math
    â”‚             â”‚   â”œâ”€â”€ references
    â”‚             â”‚   â”‚   â”œâ”€â”€ ANEW_ARRAY.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ ARRAY_LENGTH.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ CHECK_CAST.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ GET_FIELD.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ GET_STATIC.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INSTANCE_OF.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_INTERFACE.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_SPECIAL.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_STATIC.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ INVOKE_VIRTUAL.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ MULTI_ANEW_ARRAY.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ NEW.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ NEW_ARRAY.java
    â”‚             â”‚   â”‚   â”œâ”€â”€ PUT_FIELD.java
    â”‚             â”‚   â”‚   â””â”€â”€ PUT_STATIC.java
    â”‚             â”‚   â”œâ”€â”€ reserved
    â”‚             â”‚   â”‚   â””â”€â”€ INVOKE_NATIVE.java	
    â”‚             â”‚   â”œâ”€â”€ stack
    â”‚             â”‚   â”œâ”€â”€ store
    â”‚             â”‚   â”‚   â””â”€â”€ xastore
    â”‚             â”‚   â”‚       â”œâ”€â”€ AASTORE.java	
    â”‚             â”‚   â”‚       â”œâ”€â”€ BASTORE.java	
    â”‚             â”‚   â”‚       â”œâ”€â”€ CASTORE.java	
    â”‚             â”‚   â”‚       â”œâ”€â”€ DASTORE.java
    â”‚             â”‚   â”‚       â”œâ”€â”€ FASTORE.java
    â”‚             â”‚   â”‚       â”œâ”€â”€ IASTORE.java
    â”‚             â”‚   â”‚       â”œâ”€â”€ LASTORE.java	
    â”‚             â”‚   â”‚       â””â”€â”€ SASTORE.java		
    â”‚             â”‚   â””â”€â”€ Factory   
    â”‚             â”œâ”€â”€ rtda
    â”‚             â”‚   â”œâ”€â”€ heap
    â”‚             â”‚   â”‚   â”œâ”€â”€ constantpool
    â”‚             â”‚   â”‚   â”œâ”€â”€ methodarea
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Class.java    
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ ClassMember.java  
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Field.java    
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Method.java 
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ MethodDescriptor.java 
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ MethodDescriptorParser.java 
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ MethodLookup.java 	
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Object.java   
    â”‚             â”‚   â”‚   â”‚   â”œâ”€â”€ Slots.java   
    â”‚             â”‚   â”‚   â”‚   â””â”€â”€ StringPool.java	
    â”‚             â”‚   â”‚   â””â”€â”€ ClassLoader.java  
    â”‚             â”‚   â”œâ”€â”€ Frame.java
    â”‚             â”‚   â”œâ”€â”€ JvmStack.java
    â”‚             â”‚   â”œâ”€â”€ LocalVars.java
    â”‚             â”‚   â”œâ”€â”€ OperandStack.java
    â”‚             â”‚   â”œâ”€â”€ Slot.java 
    â”‚             â”‚   â””â”€â”€ Thread.java
    â”‚             â”œâ”€â”€ Cmd.java
    â”‚             â”œâ”€â”€ Interpret.java    
    â”‚             â””â”€â”€ Main.java
    â””â”€â”€ test
         â””â”€â”€ java
             â””â”€â”€ org.itstack.demo.test
                 â””â”€â”€ HelloWorld.java
```

ä»£ç ç‰‡æ®µ

>_Class.java

```java
package org.itstack.demo.jvm._native.java;

import org.itstack.demo.jvm._native.NativeMethod;
import org.itstack.demo.jvm._native.Registry;
import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.LocalVars;
import org.itstack.demo.jvm.rtda.OperandStack;
import org.itstack.demo.jvm.rtda.heap.ClassLoader;
import org.itstack.demo.jvm.rtda.heap.methodarea.Class;
import org.itstack.demo.jvm.rtda.heap.methodarea.Object;
import org.itstack.demo.jvm.rtda.heap.methodarea.StringPool;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/30
 */
public class _Class {

    private final String jlClass = "java/lang/Class";

    public _Class() {
        Registry.register(jlClass, "getPrimitiveClass", "(Ljava/lang/String;)Ljava/lang/Class;", new NativeMethod(this, "getPrimitiveClass"));
        Registry.register(jlClass, "getName0", "()Ljava/lang/String;", new NativeMethod(this, "getName0"));
        Registry.register(jlClass, "desiredAssertionStatus0", "(Ljava/lang/Class;)Z", new NativeMethod(this, "desiredAssertionStatus0"));
        Registry.register(jlClass, "registerNatives", "()V", new NativeMethod(this, "registerNatives"));
    }

    public void registerNatives(Frame frame) {
        // do nothing
    }

    public void getPrimitiveClass(Frame frame) {
        Object nameObj = frame.localVars().getRef(0);
        String name = StringPool.goString(nameObj);

        ClassLoader loader = frame.method().clazz().loader();
        Object jClass = loader.loadClass(name).jClass();

        frame.operandStack().pushRef(jClass);
    }

    public void getName0(Frame frame) {
        Object thiz = frame.localVars().getThis();
        Class clazz = (Class) thiz.extra();

        String name = "è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼š" + clazz.javaName();
        Object nameObj = StringPool.jString(clazz.loader(), name);

        frame.operandStack().pushRef(nameObj);
    }

    public void desiredAssertionStatus0(Frame frame) {
        frame.operandStack().pushBoolean(false);
    }

    public void isInterface(Frame frame) {
        LocalVars vars = frame.localVars();
        Object thiz = vars.getThis();
        Class clazz = (Class) thiz.extra();

        OperandStack stack = frame.operandStack();
        stack.pushBoolean(clazz.isInterface());
    }

    public void isPrimitive(Frame frame) {
        LocalVars vars = frame.localVars();
        Object thiz = vars.getThis();
        Class clazz = (Class) thiz.extra();

        OperandStack stack = frame.operandStack();
        stack.pushBoolean(clazz.IsPrimitive());
    }

}
```

>_System.java	

```java
package org.itstack.demo.jvm._native.java;

import org.itstack.demo.jvm._native.NativeMethod;
import org.itstack.demo.jvm._native.Registry;
import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.LocalVars;
import org.itstack.demo.jvm.rtda.heap.methodarea.Class;
import org.itstack.demo.jvm.rtda.heap.methodarea.Object;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/30
 */
public class _System {

    private final String jlSystem = "java/lang/System";

    public _System() {
        Registry.register(jlSystem, "arraycopy", "()Ljava/lang/String;", new NativeMethod(this, "arraycopy"));
        Registry.register(jlSystem,"registerNatives", "()V",new NativeMethod(this,"registerNatives"));
    }

    public void registerNatives(Frame frame) {
        // do nothing
    }
    
    public void arraycopy(Frame frame) {
        LocalVars vars = frame.localVars();
        Object src = vars.getRef(0);
        int srcPos = vars.getInt(1);
        Object dest = vars.getRef(2);
        int destPos = vars.getInt(4);
        int length = vars.getInt(4);

        if (null == src || dest == null) {
            throw new NullPointerException();
        }

        if (!checkArrayCopy(src, dest)) {
            throw new ArrayStoreException();
        }

        if (srcPos < 0 || destPos < 0 || length < 0 ||
                srcPos + length > src.arrayLength() ||
                destPos + length > dest.arrayLength()) {
            throw new IndexOutOfBoundsException();
        }

        System.arraycopy(src, srcPos, dest, destPos, length);

        //todo å¾…å®Œå–„

    }

    public boolean checkArrayCopy(Object src, Object dest) {
        Class srcClass = src.clazz();
        Class destClass = dest.clazz();

        if (!srcClass.isArray() || !destClass.isArray()) {
            return false;
        }

        if (srcClass.componentClass().IsPrimitive() || destClass.componentClass().IsPrimitive()) {
            return srcClass == destClass;
        }

        return true;

    }

}
```

>NativeMethod.java

```java
package org.itstack.demo.jvm._native;

import org.itstack.demo.jvm.rtda.Frame;

import java.lang.reflect.Method;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/30
 */
public class NativeMethod {

    private String methodName;
    private Object obj;

    public NativeMethod(Object obj, String methodName) {
        this.methodName = methodName;
        this.obj = obj;
    }

    public void invoke(Frame frame) {
        try {
            Method method = obj.getClass().getMethod(methodName, frame.getClass());
            method.invoke(obj, frame);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```

>Registry.java	

```java
package org.itstack.demo.jvm._native;

import org.itstack.demo.jvm._native.java.*;

import java.util.HashMap;
import java.util.Map;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/4/30
 */
public class Registry {

    private static Map<String, NativeMethod> registry = new HashMap<>();

    //åˆå§‹åŒ–æœ¬åœ°æ–¹æ³•
    public static void initNative() {
        new _Class();
        new _Double();
        new _Float();
        new _Object();
        new _String();
        new _System();
    }

    public static void register(String className, String methodName, String methodDescriptor, NativeMethod method) {
        String key = className + "~" + methodName + "~" + methodDescriptor;
        registry.put(key, method);
    }

    public static NativeMethod findNativeMethod(String className, String methodName, String methodDescriptor) {
        String key = className + "~" + methodName + "~" + methodDescriptor;
        return registry.get(key);
    }

}
```

>INVOKE_NATIVE.java	

```java
package org.itstack.demo.jvm.instructions.reserved;

import org.itstack.demo.jvm._native.NativeMethod;
import org.itstack.demo.jvm._native.Registry;
import org.itstack.demo.jvm.instructions.base.InstructionNoOperands;
import org.itstack.demo.jvm.rtda.Frame;
import org.itstack.demo.jvm.rtda.heap.methodarea.Method;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/2
 */
public class INVOKE_NATIVE extends InstructionNoOperands {

    @Override
    public void execute(Frame frame) {
        Method method = frame.method();
        String className = method.clazz().name();
        String methodName = method.name();
        String methodDescriptor = method.descriptor();

        NativeMethod nativeMethod = Registry.findNativeMethod(className, methodName, methodDescriptor);
        if (null == nativeMethod) {
            String methodInfo = className + "." + methodName + methodDescriptor;
            throw new UnsatisfiedLinkError(methodInfo);
        }

        nativeMethod.invoke(frame);

    }

}
```

>ClassLoader.java

```java
package org.itstack.demo.jvm.rtda.heap;

import org.itstack.demo.jvm.classfile.ClassFile;
import org.itstack.demo.jvm.classpath.Classpath;
import org.itstack.demo.jvm.rtda.heap.constantpool.AccessFlags;
import org.itstack.demo.jvm.rtda.heap.methodarea.*;
import org.itstack.demo.jvm.rtda.heap.constantpool.RunTimeConstantPool;
import org.itstack.demo.jvm.rtda.heap.methodarea.Class;
import org.itstack.demo.jvm.rtda.heap.methodarea.Object;

import java.util.HashMap;
import java.util.Map;

/*
class names:
    - primitive types: boolean, byte, int ...
    - primitive arrays: [Z, [B, [I ...
    - non-array classes: java/lang/Object ...
    - array classes: [Ljava/lang/Object; ...
*/
public class ClassLoader {

    private Classpath classpath;
    private Map<String, Class> classMap;

    public ClassLoader(Classpath classpath) {
        this.classpath = classpath;
        this.classMap = new HashMap<>();

        this.loadBasicClasses();
        this.loadPrimitiveClasses();
    }

    private void loadBasicClasses() {
        Class jlClassClass = this.loadClass("java/lang/Class");
        for (Map.Entry<String, Class> entry : this.classMap.entrySet()) {
            Class clazz = entry.getValue();
            if (clazz.jClass == null) {
                clazz.jClass = jlClassClass.newObject();
                clazz.jClass.extra = clazz;
            }
        }
    }

    private void loadPrimitiveClasses() {
        for (Map.Entry<String, String> entry : ClassNameHelper.primitiveTypes.entrySet()) {
            loadPrimitiveClass(entry.getKey());
        }
    }

    private void loadPrimitiveClass(String className) {
        Class clazz = new Class(AccessFlags.ACC_PUBLIC,
                className,
                this,
                true);
        clazz.jClass = this.classMap.get("java/lang/Class").newObject();
        clazz.jClass.extra = clazz;
        this.classMap.put(className, clazz);
    }

    public Class loadClass(String className) {
        Class clazz = classMap.get(className);
        if (null != clazz) return clazz;

        //'['æ•°ç»„æ ‡è¯†
        if (className.getBytes()[0] == '[') {
            clazz = loadArrayClass(className);
        } else {
            clazz = loadNonArrayClass(className);
        }

        Class jlClazz = this.classMap.get("java/lang/Class");
        if (null != jlClazz && null != clazz) {
            clazz.jClass = jlClazz.newObject();
            clazz.jClass.extra = clazz;
        }

        return clazz;
    }

    private Class loadArrayClass(String className) {
        Class clazz = new Class(AccessFlags.ACC_PUBLIC,
                className,
                this,
                true,
                this.loadClass("java/lang/Object"),
                new Class[]{
                        this.loadClass("java/lang/Cloneable"),
                        this.loadClass("java/io/Serializable")});
        this.classMap.put(className, clazz);
        return clazz;
    }

    private Class loadNonArrayClass(String className) {
        try {
            byte[] data = this.classpath.readClass(className);
            if (null == data) {
                throw new ClassNotFoundException(className);
            }
            Class clazz = defineClass(data);
            link(clazz);
            return clazz;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private void link(Class clazz) {
        verify(clazz);
        prepare(clazz);
    }

    private void prepare(Class clazz) {
        calcInstanceFieldSlotIds(clazz);
        calcStaticFieldSlotIds(clazz);
        allocAndInitStaticVars(clazz);
    }

    private void allocAndInitStaticVars(Class clazz) {
        clazz.staticVars = new Slots(clazz.staticSlotCount);
        for (Field field : clazz.fields) {
            if (field.isStatic() && field.isFinal()) {
                initStaticFinalVar(clazz, field);
            }
        }
    }

    private void initStaticFinalVar(Class clazz, Field field) {
        Slots staticVars = clazz.staticVars;
        RunTimeConstantPool constantPool = clazz.runTimeConstantPool;
        int cpIdx = field.constValueIndex();
        int slotId = field.slotId();

        if (cpIdx > 0) {
            switch (field.descriptor()) {
                case "Z":
                case "B":
                case "C":
                case "S":
                case "I":
                    java.lang.Object val = constantPool.getConstants(cpIdx);
                    staticVars.setInt(slotId, (Integer) val);
                    break;
                case "J":
                    staticVars.setLong(slotId, (Long) constantPool.getConstants(cpIdx));
                    break;
                case "F":
                    staticVars.setFloat(slotId, (Float) constantPool.getConstants(cpIdx));
                    break;
                case "D":
                    staticVars.setDouble(slotId, (Double) constantPool.getConstants(cpIdx));
                    break;
                case "Ljava/lang/String;":
                    String goStr = (String) constantPool.getConstants(cpIdx);
                    Object jStr = StringPool.jString(clazz.loader(), goStr);
                    staticVars.setRef(slotId, jStr);
                    break;
            }
        }

    }

    private void calcStaticFieldSlotIds(Class clazz) {
        int slotId = 0;
        for (Field field : clazz.fields) {
            if (field.isStatic()) {
                field.slotId = slotId;
                slotId++;
                if (field.isLongOrDouble()) {
                    slotId++;
                }
            }
        }
        clazz.staticSlotCount = slotId;
    }

    private void calcInstanceFieldSlotIds(Class clazz) {
        int slotId = 0;
        if (clazz.superClass != null) {
            slotId = clazz.superClass.instanceSlotCount;
        }
        for (Field field : clazz.fields) {
            if (!field.isStatic()) {
                field.slotId = slotId;
                slotId++;
                if (field.isLongOrDouble()) {
                    slotId++;
                }
            }
        }
        clazz.instanceSlotCount = slotId;
    }

    private void verify(Class clazz) {
        // æ ¡éªŒå­—èŠ‚ç ï¼Œå°šæœªå®ç°
    }

    private Class defineClass(byte[] data) throws Exception {
        Class clazz = parseClass(data);
        clazz.loader = this;
        resolveSuperClass(clazz);
        resolveInterfaces(clazz);
        this.classMap.put(clazz.name, clazz);
        return clazz;
    }

    private void resolveInterfaces(Class clazz) throws Exception {
        int interfaceCount = clazz.interfaceNames.length;
        if (interfaceCount > 0) {
            clazz.interfaces = new Class[interfaceCount];
            for (int i = 0; i < interfaceCount; i++) {
                clazz.interfaces[i] = clazz.loader.loadClass(clazz.interfaceNames[i]);
            }
        }
    }

    private void resolveSuperClass(Class clazz) throws Exception {
        if (!clazz.name.equals("java/lang/Object")) {
            clazz.superClass = clazz.loader.loadClass(clazz.superClassName);
        }
    }

    private Class parseClass(byte[] data) {
        ClassFile classFile = new ClassFile(data);
        return new Class(classFile);
    }


}
```

>HelloWorld.java

```java
package org.itstack.demo.test;

/**
 * -Xjre "C:\Program Files\Java\jdk1.8.0_161\jre" E:\itstack\git\istack-demo\itstack-demo-jvm\itstack-demo-jvm-09\target\test-classes\org\itstack\demo\test\HelloWorld -verbose true -args ä½ å¥½ï¼Œjavaç‰ˆè™šæ‹Ÿæœºv1.0ï¼Œæ¬¢è¿ä½ çš„åˆ°æ¥ã€‚
 */
public class HelloWorld {

    public static void main(String[] args) {
        System.out.println(byte.class.getName()); // byte
        System.out.println(void.class.getName()); // void
        System.out.println(boolean.class.getName()); // boolean
        System.out.println(char.class.getName()); // char
        System.out.println(short.class.getName()); // short
        System.out.println(int.class.getName()); // int
        System.out.println(long.class.getName()); // long
        System.out.println(float.class.getName()); // float
        System.out.println(double.class.getName()); // double
        System.out.println(Object.class.getName()); // java.lang.Object
        System.out.println(int[].class.getName()); // [I
        System.out.println(int[][].class.getName()); // [[I
        System.out.println(Object[].class.getName()); // [Ljava.lang.Object;
        System.out.println(Object[][].class.getName()); // [[Ljava.lang.Object;
    }

}
```

## æµ‹è¯•ç»“æœ
```java
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šbyte
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼švoid
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šboolean
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šchar
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šshort
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šint
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šlong
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šfloat
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šdouble
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼šjava.lang.Object
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼š[I
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼š[[I
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼š[Ljava.lang.Object;
è™šæ‹Ÿæœºæœ¬åœ°æ–¹æ³•getName0è·å–ç±»åï¼š[[Ljava.lang.Object;
```

å¾®ä¿¡æœç´¢ã€Œ**bugstackè™«æ´æ ˆ**ã€å…¬ä¼—å·ï¼Œå…³æ³¨åå›å¤ã€Œ**ç”¨Javaå®ç°jvmæºç **ã€è·å–æœ¬æ–‡æºç &æ›´å¤šåŸåˆ›ä¸“é¢˜æ¡ˆä¾‹ï¼
