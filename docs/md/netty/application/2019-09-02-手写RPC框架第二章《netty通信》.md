---
layout: post
category: itstack-demo-netty-3
title: æ‰‹å†™RPCæ¡†æ¶ç¬¬äºŒç« ã€Šnettyé€šä¿¡ã€‹
tagline: by ä»˜æ”¿å§”
tag: [netty,itstack-demo-netty-3] 
lock: need
---

# æ‰‹å†™RPCæ¡†æ¶ç¬¬äºŒç« ã€Šnettyé€šä¿¡ã€‹

ä½œè€…ï¼šå°å‚…å“¥
<br/>åšå®¢ï¼š[https://bugstack.cn](https://bugstack.cn)

> æ²‰æ·€ã€åˆ†äº«ã€æˆé•¿ï¼Œè®©è‡ªå·±å’Œä»–äººéƒ½èƒ½æœ‰æ‰€æ”¶è·ï¼ğŸ˜„

## æ¡ˆä¾‹ä»‹ç»
åœ¨æˆ‘ä»¬å®ç°rpcæ¡†æ¶çš„æ—¶å€™ï¼Œéœ€è¦é€‰æ‹©socketçš„é€šä¿¡æ–¹å¼ã€‚è€Œæˆ‘ä»¬çŸ¥é“ä¸€èˆ¬æƒ…å†µä¸‹socketé€šä¿¡ç±»ä¼¼ä¸qqèŠå¤©ï¼Œå‘è¿‡å»æ¶ˆæ¯ï¼Œä»€ä¹ˆæ—¶å€™å›å¤éƒ½å¯ä»¥ã€‚ä½†æ˜¯æˆ‘ä»¬rpcæ¡†æ¶é€šä¿¡ï¼Œä»æ„Ÿè§‰ä¸Šç±»ä¼¼httpè°ƒç”¨ï¼Œéœ€è¦åœ¨ä¸€å®šæ—¶é—´å†…è¿”å›ï¼Œå¦åˆ™å°±ä¼šå‘ç”Ÿè¶…æ—¶æ–­å¼€ã€‚

è¿™é‡Œæˆ‘ä»¬é€‰æ‹©nettyä½œä¸ºæˆ‘ä»¬çš„socketæ¡†æ¶ï¼Œé‡‡ç”¨futureæ–¹å¼è¿›è¡Œé€šä¿¡ã€‚
>Nettyæ˜¯ç”±JBOSSæä¾›çš„ä¸€ä¸ªjavaå¼€æºæ¡†æ¶ã€‚Nettyæä¾›å¼‚æ­¥çš„ã€äº‹ä»¶é©±åŠ¨çš„ç½‘ç»œåº”ç”¨ç¨‹åºæ¡†æ¶å’Œå·¥å…·ï¼Œç”¨ä»¥å¿«é€Ÿå¼€å‘é«˜æ€§èƒ½ã€é«˜å¯é æ€§çš„ç½‘ç»œæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ç¨‹åºã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒNetty æ˜¯ä¸€ä¸ªåŸºäºNIOçš„å®¢æˆ·ã€æœåŠ¡å™¨ç«¯ç¼–ç¨‹æ¡†æ¶ï¼Œä½¿ç”¨Netty å¯ä»¥ç¡®ä¿ä½ å¿«é€Ÿå’Œç®€å•çš„å¼€å‘å‡ºä¸€ä¸ªç½‘ç»œåº”ç”¨ï¼Œä¾‹å¦‚å®ç°äº†æŸç§åè®®çš„å®¢æˆ·ã€æœåŠ¡ç«¯åº”ç”¨ã€‚Nettyç›¸å½“äºç®€åŒ–å’Œæµçº¿åŒ–äº†ç½‘ç»œåº”ç”¨çš„ç¼–ç¨‹å¼€å‘è¿‡ç¨‹ï¼Œä¾‹å¦‚ï¼šåŸºäºTCPå’ŒUDPçš„socketæœåŠ¡å¼€å‘ã€‚â€œå¿«é€Ÿâ€å’Œâ€œç®€å•â€å¹¶ä¸ç”¨äº§ç”Ÿç»´æŠ¤æ€§æˆ–æ€§èƒ½ä¸Šçš„é—®é¢˜ã€‚Netty æ˜¯ä¸€ä¸ªå¸æ”¶äº†å¤šç§åè®®ï¼ˆåŒ…æ‹¬FTPã€SMTPã€HTTPç­‰å„ç§äºŒè¿›åˆ¶æ–‡æœ¬åè®®ï¼‰çš„å®ç°ç»éªŒï¼Œå¹¶ç»è¿‡ç›¸å½“ç²¾å¿ƒè®¾è®¡çš„é¡¹ç›®ã€‚æœ€ç»ˆï¼ŒNetty æˆåŠŸçš„æ‰¾åˆ°äº†ä¸€ç§æ–¹å¼ï¼Œåœ¨ä¿è¯æ˜“äºå¼€å‘çš„åŒæ—¶è¿˜ä¿è¯äº†å…¶åº”ç”¨çš„æ€§èƒ½ï¼Œç¨³å®šæ€§å’Œä¼¸ç¼©æ€§ã€‚


## ç¯å¢ƒå‡†å¤‡
1. jdk 1.8.0
2. IntelliJ IDEA Community Edition 2018.3.1 x64

## ä»£ç ç¤ºä¾‹
```
itstack-demo-rpc-02
â””â”€â”€ src
    â””â”€â”€ main
    â”‚    â””â”€â”€ java
    â”‚        â””â”€â”€ org.itstack.demo.rpc.network
    â”‚             â”œâ”€â”€ client
    â”‚             â”‚   â”œâ”€â”€ ClientSocket.java
    â”‚             â”‚   â””â”€â”€ MyClientHandler.java  
    â”‚             â”œâ”€â”€ codec
    â”‚             â”‚   â”œâ”€â”€ RpcDecoder.java
    â”‚             â”‚   â””â”€â”€ RpcEncoder.java  
    â”‚             â”œâ”€â”€ future
    â”‚             â”‚   â”œâ”€â”€ SyncWrite.java 	
    â”‚             â”‚   â”œâ”€â”€ SyncWriteFuture.java	
    â”‚             â”‚   â”œâ”€â”€ SyncWriteMap.java	
    â”‚             â”‚   â””â”€â”€ WriteFuture.java	
    â”‚             â”œâ”€â”€ msg
    â”‚             â”‚   â”œâ”€â”€ Request.java
    â”‚             â”‚   â””â”€â”€ Response.java 
    â”‚             â”œâ”€â”€ server
    â”‚             â”‚   â”œâ”€â”€ MyServerHandler.java
    â”‚             â”‚   â””â”€â”€ ServerSocket.java 	
    â”‚             â””â”€â”€ util
    â”‚                 â””â”€â”€ SerializationUtil.java 	
    â””â”€â”€ test
         â””â”€â”€ java
             â””â”€â”€ org.itstack.demo.test
                 â”œâ”€â”€ client
            	 â”‚   â””â”€â”€ StartClient.java
                 â””â”€â”€ server
            	     â””â”€â”€ StartServer.java				 

```

>ClientSocket.java

```java
package org.itstack.demo.rpc.network.client;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import org.itstack.demo.rpc.network.codec.RpcDecoder;
import org.itstack.demo.rpc.network.codec.RpcEncoder;
import org.itstack.demo.rpc.network.msg.Request;
import org.itstack.demo.rpc.network.msg.Response;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class ClientSocket implements Runnable {

    private ChannelFuture future;

    @Override
    public void run() {
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            Bootstrap b = new Bootstrap();
            b.group(workerGroup);
            b.channel(NioSocketChannel.class);
            b.option(ChannelOption.AUTO_READ, true);
            b.handler(new ChannelInitializer<SocketChannel>() {
                @Override
                public void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(
                            new RpcDecoder(Response.class),
                            new RpcEncoder(Request.class),
                            new MyClientHandler());
                }
            });
            ChannelFuture f = b.connect("127.0.0.1", 7397).sync();
            this.future = f;
            f.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            workerGroup.shutdownGracefully();
        }
    }

    public ChannelFuture getFuture() {
        return future;
    }

    public void setFuture(ChannelFuture future) {
        this.future = future;
    }
}
```

>MyClientHandler.java

```java
package org.itstack.demo.rpc.network.client;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import org.itstack.demo.rpc.network.future.SyncWriteFuture;
import org.itstack.demo.rpc.network.future.SyncWriteMap;
import org.itstack.demo.rpc.network.msg.Response;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class MyClientHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object obj) throws Exception {
        Response msg = (Response) obj;
        String requestId = msg.getRequestId();
        SyncWriteFuture future = (SyncWriteFuture) SyncWriteMap.syncKey.get(requestId);
        if (future != null) {
            future.setResponse(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }

}
```

>RpcDecoder.java

```java
package org.itstack.demo.rpc.network.codec;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ByteToMessageDecoder;
import org.itstack.demo.rpc.network.util.SerializationUtil;

import java.util.List;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class RpcDecoder extends ByteToMessageDecoder {

    private Class<?> genericClass;

    public RpcDecoder(Class<?> genericClass) {
        this.genericClass = genericClass;
    }

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        if (in.readableBytes() < 4) {
            return;
        }
        in.markReaderIndex();
        int dataLength = in.readInt();
        if (in.readableBytes() < dataLength) {
            in.resetReaderIndex();
            return;
        }
        byte[] data = new byte[dataLength];
        in.readBytes(data);
        out.add(SerializationUtil.deserialize(data, genericClass));
    }

}
```

>RpcEncoder.java 

```java
package org.itstack.demo.rpc.network.codec;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToByteEncoder;
import org.itstack.demo.rpc.network.util.SerializationUtil;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class RpcEncoder extends MessageToByteEncoder {

    private Class<?> genericClass;

    public RpcEncoder(Class<?> genericClass) {
        this.genericClass = genericClass;
    }

    @Override
    protected void encode(ChannelHandlerContext ctx, Object in, ByteBuf out)  {
        if (genericClass.isInstance(in)) {
            byte[] data = SerializationUtil.serialize(in);
            out.writeInt(data.length);
            out.writeBytes(data);
        }
    }

}
```

>SyncWrite.java

```java
package org.itstack.demo.rpc.network.future;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import org.itstack.demo.rpc.network.msg.Request;
import org.itstack.demo.rpc.network.msg.Response;

import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class SyncWrite {

    public Response writeAndSync(final Channel channel, final Request request, final long timeout) throws Exception {

        if (channel == null) {
            throw new NullPointerException("channel");
        }
        if (request == null) {
            throw new NullPointerException("request");
        }
        if (timeout <= 0) {
            throw new IllegalArgumentException("timeout <= 0");
        }

        String requestId = UUID.randomUUID().toString();
        request.setRequestId(requestId);

        WriteFuture<Response> future = new SyncWriteFuture(request.getRequestId());
        SyncWriteMap.syncKey.put(request.getRequestId(), future);

        Response response = doWriteAndSync(channel, request, timeout, future);

        SyncWriteMap.syncKey.remove(request.getRequestId());
        return response;
    }

    private Response doWriteAndSync(final Channel channel, final Request request, final long timeout, final WriteFuture<Response> writeFuture) throws Exception {

        channel.writeAndFlush(request).addListener(new ChannelFutureListener() {
            public void operationComplete(ChannelFuture future) throws Exception {
                writeFuture.setWriteResult(future.isSuccess());
                writeFuture.setCause(future.cause());
                //å¤±è´¥ç§»é™¤
                if (!writeFuture.isWriteSuccess()) {
                    SyncWriteMap.syncKey.remove(writeFuture.requestId());
                }
            }
        });

        Response response = writeFuture.get(timeout, TimeUnit.MILLISECONDS);
        if (response == null) {
            if (writeFuture.isTimeout()) {
                throw new TimeoutException();
            } else {
                // write exception
                throw new Exception(writeFuture.cause());
            }
        }
        return response;
    }

}
```

>SyncWriteFuture.java

```java
package org.itstack.demo.rpc.network.future;


import org.itstack.demo.rpc.network.msg.Response;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class SyncWriteFuture implements WriteFuture<Response> {

    private CountDownLatch latch = new CountDownLatch(1);
    private final long begin = System.currentTimeMillis();
    private long timeout;
    private Response response;
    private final String requestId;
    private boolean writeResult;
    private Throwable cause;
    private boolean isTimeout = false;

    public SyncWriteFuture(String requestId) {
        this.requestId = requestId;
    }

    public SyncWriteFuture(String requestId, long timeout) {
        this.requestId = requestId;
        this.timeout = timeout;
        writeResult = true;
        isTimeout = false;
    }


    public Throwable cause() {
        return cause;
    }

    public void setCause(Throwable cause) {
        this.cause = cause;
    }

    public boolean isWriteSuccess() {
        return writeResult;
    }

    public void setWriteResult(boolean result) {
        this.writeResult = result;
    }

    public String requestId() {
        return requestId;
    }

    public Response response() {
        return response;
    }

    public void setResponse(Response response) {
        this.response = response;
        latch.countDown();
    }

    public boolean cancel(boolean mayInterruptIfRunning) {
        return true;
    }

    public boolean isCancelled() {
        return false;
    }

    public boolean isDone() {
        return false;
    }

    public Response get() throws InterruptedException, ExecutionException {
        latch.wait();
        return response;
    }

    public Response get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        if (latch.await(timeout, unit)) {
            return response;
        }
        return null;
    }

    public boolean isTimeout() {
        if (isTimeout) {
            return isTimeout;
        }
        return System.currentTimeMillis() - begin > timeout;
    }
}
```

>SyncWriteMap.java

```java
package org.itstack.demo.rpc.network.future;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class SyncWriteMap {

    public static Map<String, WriteFuture> syncKey = new ConcurrentHashMap<String, WriteFuture>();

}
```

>WriteFuture.java	

```java
package org.itstack.demo.rpc.network.future;

import org.itstack.demo.rpc.network.msg.Response;

import java.util.concurrent.Future;

public interface WriteFuture<T> extends Future<T> {

    Throwable cause();

    void setCause(Throwable cause);

    boolean isWriteSuccess();

    void setWriteResult(boolean result);

    String requestId();

    T response();

    void setResponse(Response response);

    boolean isTimeout();


}
```

>Request.java

```java
package org.itstack.demo.rpc.network.msg;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class Request {

    private String requestId;
    private Object result;

    public String getRequestId() {
        return requestId;
    }

    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }

    public Object getResult() {
        return result;
    }

    public void setResult(Object result) {
        this.result = result;
    }

}
```

>Response.java

```java
package org.itstack.demo.rpc.network.msg;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class Response {

    private String requestId;
    private String param;

    public String getRequestId() {
        return requestId;
    }

    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }

    public String getParam() {
        return param;
    }

    public void setParam(String param) {
        this.param = param;
    }

}
```

>MyServerHandler.java

```java
package org.itstack.demo.rpc.network.server;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.ReferenceCountUtil;
import org.itstack.demo.rpc.network.msg.Request;
import org.itstack.demo.rpc.network.msg.Response;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class MyServerHandler extends ChannelInboundHandlerAdapter{

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object obj){
        Request msg = (Request) obj;
        //åé¦ˆ
        Response request = new Response();
        request.setRequestId(msg.getRequestId());
        request.setParam(msg.getResult() + " è¯·æ±‚æˆåŠŸï¼Œåé¦ˆç»“æœè¯·æ¥å—å¤„ç†ã€‚");
        ctx.writeAndFlush(request);
        //é‡Šæ”¾
        ReferenceCountUtil.release(msg);
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

}
```

>ServerSocket.java

```java
package org.itstack.demo.rpc.network.server;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import org.itstack.demo.rpc.network.codec.RpcDecoder;
import org.itstack.demo.rpc.network.codec.RpcEncoder;
import org.itstack.demo.rpc.network.msg.Request;
import org.itstack.demo.rpc.network.msg.Response;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class ServerSocket implements Runnable {

    private ChannelFuture f;

    @Override
    public void run() {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        public void initChannel(SocketChannel ch){
                            ch.pipeline().addLast(
                                    new RpcDecoder(Request.class),
                                    new RpcEncoder(Response.class),
                                    new MyServerHandler());
                        }
                    });

            ChannelFuture f = null;
            f = b.bind(7397).sync();
            f.channel().closeFuture().sync();


        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }

    }

}
```

>SerializationUtil.java

```java
package org.itstack.demo.rpc.network.util;

import com.dyuproject.protostuff.LinkedBuffer;
import com.dyuproject.protostuff.ProtostuffIOUtil;
import com.dyuproject.protostuff.Schema;
import com.dyuproject.protostuff.runtime.RuntimeSchema;
import org.objenesis.Objenesis;
import org.objenesis.ObjenesisStd;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by fuzhengwei1 on 2016/10/20.
 */
public class SerializationUtil {

    private static Map<Class<?>, Schema<?>> cachedSchema = new ConcurrentHashMap();

    private static Objenesis objenesis = new ObjenesisStd();

    private SerializationUtil() {

    }

    /**
     * åºåˆ—åŒ–(å¯¹è±¡ -> å­—èŠ‚æ•°ç»„)
     *
     * @param obj å¯¹è±¡
     * @return å­—èŠ‚æ•°ç»„
     */
    public static <T> byte[] serialize(T obj) {
        Class<T> cls = (Class<T>) obj.getClass();
        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
        try {
            Schema<T> schema = getSchema(cls);
            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        } finally {
            buffer.clear();
        }
    }

    /**
     * ååºåˆ—åŒ–(å­—èŠ‚æ•°ç»„ -> å¯¹è±¡)
     *
     * @param data
     * @param cls
     * @param <T>
     */
    public static <T> T deserialize(byte[] data, Class<T> cls) {
        try {
            T message = objenesis.newInstance(cls);
            Schema<T> schema = getSchema(cls);
            ProtostuffIOUtil.mergeFrom(data, message, schema);
            return message;
        } catch (Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    private static <T> Schema<T> getSchema(Class<T> cls) {
        Schema<T> schema = (Schema<T>) cachedSchema.get(cls);
        if (schema == null) {
            schema = RuntimeSchema.createFrom(cls);
            cachedSchema.put(cls, schema);
        }
        return schema;
    }

}
```

>StartClient.java

```java
package org.itstack.demo.test.client;

import com.alibaba.fastjson.JSON;
import io.netty.channel.ChannelFuture;
import org.itstack.demo.rpc.network.client.ClientSocket;
import org.itstack.demo.rpc.network.future.SyncWrite;
import org.itstack.demo.rpc.network.msg.Request;
import org.itstack.demo.rpc.network.msg.Response;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class StartClient {

    private static ChannelFuture future;

    public static void main(String[] args) {
        ClientSocket client = new ClientSocket();
        new Thread(client).start();

        while (true) {
            try {
                //è·å–futureï¼Œçº¿ç¨‹æœ‰ç­‰å¾…å¤„ç†æ—¶é—´
                if (null == future) {
                    future = client.getFuture();
                    Thread.sleep(500);
                    continue;
                }
                //æ„å»ºå‘é€å‚æ•°
                Request request = new Request();
                request.setResult("æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯");
                SyncWrite s = new SyncWrite();
                Response response = s.writeAndSync(future.channel(), request, 1000);
                System.out.println("è°ƒç”¨ç»“æœï¼š" + JSON.toJSON(response));
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

}
```

StartServer.java
```
package org.itstack.demo.test.server;

import org.itstack.demo.rpc.network.server.ServerSocket;

/**
 * http://www.itstack.org
 * create by fuzhengwei on 2019/5/6
 */
public class StartServer {

    public static void main(String[] args) {
        System.out.println("å¯åŠ¨æœåŠ¡ç«¯å¼€å§‹");
        new Thread(new ServerSocket()).start();
        System.out.println("å¯åŠ¨æœåŠ¡ç«¯å®Œæˆ");
    }

}
```

## æµ‹è¯•ç»“æœ

å¯åŠ¨StartServer

```java
å¯åŠ¨æœåŠ¡ç«¯å¼€å§‹
å¯åŠ¨æœåŠ¡ç«¯å®Œæˆ
log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
```

å¯åŠ¨StartClient

```java
log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
è°ƒç”¨ç»“æœï¼š{"param":"æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ è¯·æ±‚æˆåŠŸï¼Œåé¦ˆç»“æœè¯·æ¥å—å¤„ç†ã€‚","requestId":"3380f061-2501-49b5-998b-21b5956fe60a"}
è°ƒç”¨ç»“æœï¼š{"param":"æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ è¯·æ±‚æˆåŠŸï¼Œåé¦ˆç»“æœè¯·æ¥å—å¤„ç†ã€‚","requestId":"81c51815-4d92-482c-bd05-e4b6dfa4d3b6"}
è°ƒç”¨ç»“æœï¼š{"param":"æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ è¯·æ±‚æˆåŠŸï¼Œåé¦ˆç»“æœè¯·æ¥å—å¤„ç†ã€‚","requestId":"7af01c4f-a438-47a1-b35c-8e2cd7e4a5e7"}
è°ƒç”¨ç»“æœï¼š{"param":"æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ è¯·æ±‚æˆåŠŸï¼Œåé¦ˆç»“æœè¯·æ¥å—å¤„ç†ã€‚","requestId":"86e38bb1-eccc-4d45-b976-c3b67999e3ab"}
è°ƒç”¨ç»“æœï¼š{"param":"æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ è¯·æ±‚æˆåŠŸï¼Œåé¦ˆç»“æœè¯·æ¥å—å¤„ç†ã€‚","requestId":"7f72002c-3b38-43d9-8452-db8797298899"}
è°ƒç”¨ç»“æœï¼š{"param":"æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ è¯·æ±‚æˆåŠŸï¼Œåé¦ˆç»“æœè¯·æ¥å—å¤„ç†ã€‚","requestId":"d566a7d4-4b0d-426b-8c09-c535ccf8eb09"}

...
```

å¾®ä¿¡æœç´¢ã€Œ**bugstackè™«æ´æ ˆ**ã€å…¬ä¼—å·ï¼Œå…³æ³¨åå›å¤ã€Œ**rpcæ¡ˆä¾‹æºç **ã€è·å–æœ¬æ–‡æºç &æ›´å¤šåŸåˆ›ä¸“é¢˜æ¡ˆä¾‹ï¼



