---
title: 第5节：动态任务补偿处理
pay: https://t.zsxq.com/cyeBu
---

# 《本地任务消息组件》- 第5节：动态任务补偿处理

作者：小傅哥
<br/>博客：[https://bugstack.cn](https://bugstack.cn)
<br/>课程：[https://t.zsxq.com/9gZ6T](https://t.zsxq.com/9gZ6T)

>沉淀、分享、成长，让自己和他人都能有所收获！😄

## 一、本章诉求

在 Spring Event 接收到事件消息后，无论是 MQ 的发送，还是 HTTP 的调用，都是有可能失败的。可能是网络超时，可能是服务宕机，可能是线程阻塞，可能是流量洪峰等等原因。

所以，我们需要对完成 MQ、HTTP 的处理后，首先更新数据库任务表状态，是成功还是失败。之后再由定时扫描任务来做补偿处理，以确保最终一致性。

## 二、功能流程

如图，定时扫描任务流程图，以及在 http、mq 通知完成后，也要调用 dao 做变更状态操作；

<div align="center">
    <img src="https://bugstack.cn/images/article/project/local-task-message/local-task-message-5-01.png" width="750px">
</div>

- 首先，任务补偿，它是一个定时任务扫描库表的过程。这里为了提高整体的扫描效率，设计了门牌号，可以配置多个任务，每个任务扫描自己的门牌号范围。另外扫描库表，还要根据条件获取一个最小的符合的id，之后在 `> id limit x` 获取数据列表。
- 然后，还要对之前的流程做一些补充。http 调用操作、MQ 推送操作，之后要做数据库表任务记录的更新，成功或者失败。这里看，从 Spring Event 接收到消息后，执行通知操作（http、mq），之后更新数据库。这些都不是一个事务的，也就是说从事务（业务数据+任务表数据写入）往后，都是有可能失败的。所以要做任务补偿操作，那么这里也带来一个问题，补偿就有可能重复，比如 http 重复调用一次，mq 重复发送一次，所以在对这些业务长交给你对接的时候，一定要做幂等操作（比如 OrderId 做唯一索引处理）。